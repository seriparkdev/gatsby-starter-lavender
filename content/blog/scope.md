---
title: 스코프에 대해서 설명해보자
date: 2023-02-01
description: 식별자가 유효한 범위는 어디까지일까?
tags: [JavaScript]
---

```JavaScript
var x = 1;

function foo () {
	var x = 0;
}

console.log(x);
```

다음과 같은 코드가 있다고 가정합시다. console은 `foo 함수의 바깥에 있는 x`와 `foo 함수 내부에 있는 x` 중 어느 변수의 값을 출력할까요? 정답은 1입니다. 왜 그럴까요? 콘솔과 가장 가까이에 있는 것은 foo 함수 내부에 있는 x지만 콘솔이 0을 출력하는 일은 **절대** 없습니다. foo 함수의 x는 foo 함수의 영역 안에서만 유효하기 때문이죠.

**왜 foo 함수 안에서만 유효할까요?** 함수 안에 선언된 x는 **지역 스코프**를 가지기 때문입니다. 함수 블록의 내부만이 자신의 영역이고, 여기서만 유효한 존재이기 때문에 함수 바깥에서 이 x를 참조하려고 하면 참조할 수 없어요. 그럼 바깥에 선언된 변수 x는 어떤 스코프를 가질까요? 이 변수는 **전역 스코프**를 가집니다. 말 그대로 코드의 가장 바깥 영역이 x의 스코프이기 때문에 모든 곳에서 이 x를 참조할 수 있습니다.

이 두 개의 x라는 변수 간에는 무슨 차이가 있었길래 각각 다른 영역을 가지게 됐을까요? 바로 선언된 위치라는 차이가 있습니다. **자바스크립트 엔진은 x라는 변수가 무엇인지, 어떤 변수를 참조해야 할지 결정할 때 스코프에 따라서 결정하는데** 이 부분에 위치가 많은 영향을 끼칩니다. 위치에 따라 스코프가 달라지거든요.

다음 코드의 결과는 무엇일까요?

```javaScript
var x = 1;

function foo () {
	var x = 0;

    function bar () {
		var x = 2;
        console.log(x); // (?)
	}
}

```

함수가 하나 더 늘어났습니다. console은 어떤 x를 참조할까요? 답부터 말하자면 2입니다. 이 코드에 대해 설명하면서 왜 답이 2가 됐는지 알아보겠습니다. 이 상황에서 콘솔은 모든 x에 접근 가능합니다. 물론 답은 2지만요! bar 안에 x라는 변수가 없었으면 foo에 선언된 x를 참조해 0을 출력했을 것이고, foo라는 함수에 x라는 변수가 없었다면 전역 스코프를 가지고 있는 x를 참조해 1을 출력했을 것입니다.

왜 그럴까요? **지역 변수는 자신의 지역 스코프와 자신의 하위 스코프에서 유효하기 때문입니다.** 자바스크립트 엔진은 x를 찾을 때 다음과 같은 순서로 x를 찾았을 거예요.

`bar 함수 스코프` -> `foo 함수 스코프` -> `전역 스코프`

이러한 순서대로 하위에서 상위 방향으로 이동하면서 변수를 찾습니다(스코프 체인). 그렇기 때문에 상위에 있는 변수를 참조할 수 있게 된 것이에요. 즉, foo 함수에 선언된 x는 foo와 bar라는 함수 안에서접근 가능해집니다. 반대로 foo 함수의 바깥에서 foo 함수에 선언된 x를 참조할 수는 없어요. 이는 상위에서 하위 방향으로 식별자를 검색해야 가능한 일입니다.

여기서 렉시컬 환경이라는 것을 짚고 넘어가자면 **렉시컬 환경이라는 것은 쉽게 말해 문맥을 뜻해요**. 문장을 읽을 때 문맥을 파악해서 '이', '그'라는 지시대명사의 뜻을 파악할 수 있는 것처럼 자바스크립트 엔진도 이러한 문맥을 파악해야 합니다. 이 코드가 어디에 위치해 있는지, 주변에는 어떤 코드가 있는지를요.

```javascript
var x = 1;

if (true) {
var x = 6;
...
}

console.log(x);

```

여기서 콘솔은 6을 출력합니다. 아까처럼 블록 안에 있는데 왜 1이 아닌 6을 출력하고 있을까요? 그 이유는 var의 특성입니다. **var는 함수에 의해서만 지역 스코프를 생성해요.** 그렇기 때문에 if 같은 블록 레벨의 스코프에서는 영역을 생성하지 않습니다. var는 이렇게 예측하지 못한 상황을 발생시키기 때문에 사용을 지양하고, let과 const를 사용하는 것이 좋습니다. let과 const는 블록 레벨 스코프를 영역으로 인정하기 때문에 다음과 같이 결과를 예측하기가 쉬워져요.

```javascript
var x = 10;

if (true) {
  let x = 9;
}

console.log(x); // 10
```

자바스크립트는 **렉시컬 스코프를 따르기 때문에 함수를 어디에서 정의했는지가 중요합니다.** 함수가 어디에서 호출되었는가는 영향을 끼치지 않습니다. 함수가 어디서 정의되었는지에 따라 어떤 변수가 주변에 있었는지, 어디에서 이 함수가 정의되었는지 즉, 함수가 정의됐을 때의 **상위 스코프**를 기억합니다. 함수가 호출 될 때도 이 상위 스코프를 항상 기억해요.

이렇게 아까의 문제에서 답이 왜 2였는지 설명할 수 있게 되었습니다.

<br>

**참고 문서**

모던 자바스크립트 딥다이브
